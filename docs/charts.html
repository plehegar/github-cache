<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cache Charts</title>
  <script>
    // create an element easily
// attrs is object (and optional)
// content is Element or string
function domElement(namespaceURI, name, attrs, ...content) {
  const elt = document.createElementNS(name, namespaceURI);
  const makeChild = c => (c instanceof Element) ?
    c : (typeof c === 'string') ?
      document.createTextNode(c) : undefined;

  if (attrs) {
    const c = makeChild(attrs);
    if (c) {
      elt.appendChild(c);
    } else {
      for (const [name, value] of Object.entries(attrs)) {
        elt.setAttribute(name, value);
      }
    }
  }
  for (const child of content) {
    if (child instanceof Element) {
      elt.appendChild(child);
    } else {
      elt.appendChild(document.createTextNode(child));
    }
  }
  return elt;
}
function htmlElement(name, attrs, ...content) {
  return domElement(name, "http://www.w3.org/1999/xhtml", attrs, ...content);
}
function svgElement(name, attrs, ...content) {
  return domElement(name, "http://www.w3.org/2000/svg", attrs, ...content);
}

  </script>
<style>
  .duration {
    fill: darkgoldenrod;
    color: darkgoldenrod;
  }
  .domainLookup {
    fill: blue;
    color: blue;
  }
  .connect {
    fill: violet;
    color: violet;
  }
  .request {
    fill:green;
    color:green;
  }
  .response {
    fill:yellowgreen;
    color:yellowgreen;
  }
  .monitor {
    fill:blueviolet;
    color:blueviolet;
  }
  .github {
    fill:red;
    color:red;
  }
  svg {
    margin: 0;
    padding: 0;
    border: none;
  }
  main {
    max-width: 90em;
    margin: auto;
  }
  body {
    font-family: 'Roboto Condensed',Helvetica,Arial,sans-serif;
    font-weight: 300;
    background-color: #fff; color: black;
    box-sizing: border-box;
    min-height: 100%;
    padding: 2em;
  }
  h1 { text-align: center;color: #005A9C;}
  h2 {
    color: #005A9C;
    font-style: italic;
    font-size: 130%;
    font-weight: 300;
    margin: 0;
    margin-left: -1em;
  }
</style>
</head>
<body>
  <h1>GitHub Cache Charts</h1>
  <main>
    <p id='stats'>
    </p>
    <section id="chart" style='width: 100%'>
    <p style='margin: 0;padding-bottom: 0'>Maximum time is <span id='max'></span>.</span></p>
    <svg width='1000' height='2'>
      <g>
        <rect width='1000' height='2' x=0 y='0' />
      </g>
    </svg>
  </section>
  <p>
    <span class='duration'>fetch</span>
    - <span class='domainLookup'>DNS</span>
    - <span class='connect'>connection</span>
    - <span class='request'>request</span>
    - <span class='monitor'>cache</span>
    - <span class='github'>github</span>
    - <span class='response'>response</span>
  </p>
  <p><a style='float:right' href="https://github.com/plehegar/github-cache/">github-cache</a>:
    <a href='../monitor/logs'>logs</a>, <a href='../monitor/gh_logs'>gh_logs</a></p>
</main>
  <script>
    const chart = document.getElementById("chart");
    function sortBeacons(a, b) {
      if (a.receivedAt > b.receivedAt)
        return 1;
      if (a.receivedAt < b.receivedAt)
         return -1;
      return 0;
    }
    function f(n) {
      return new Intl.NumberFormat().format(n);
    }
    async function stats() {
      const usage = await fetch("../monitor/usage").then(res => res.json());
      const st = document.getElementById('stats');
      st.appendChild(htmlElement("span", `Status: ${usage.status}, `));
      st.appendChild(htmlElement("span", `Uptime: ${f(Math.floor(usage.uptime/60/60))} hours, `));
      st.appendChild(htmlElement("span", `RSS: ${Math.floor(usage.rss/1000000)}Mb, `));
      st.appendChild(htmlElement("span", `Requests: ${usage.requests.total}, `));
      st.appendChild(htmlElement("span", `Errors: ${usage.requests.errors}, `));
      st.appendChild(htmlElement("span", `GitHub Rate Remaining: ${usage.GitHub.rate.remaining}, `));
      st.appendChild(htmlElement("span", `GitHub Low Rate: ${usage.GitHub.minimumRemaining}.`));
    }
    async function beacons() {
      const beacons = await fetch("../monitor/beacon").then(res => res.json());
      const urls = {};

      for (const beacon of beacons) {
        for (const rt of beacon.resources) {
          const name = rt.name;
          let entry = urls[name];
          if (!entry) {
            entry = urls[name] = [];
          }
          rt.refer = beacon.referer;
          rt.receivedAt = beacon.receivedAt;
          rt.traceId = beacon.traceId;
          entry.push(rt);
        }
      }
      let max = 0;
      for (const key in urls) {
        urls[key] = urls[key].sort((a, b) => a.receivedAt-b.receivedAt);
        const lmax = urls[key].reduce((a, v) => (v.duration > a) ? v.duration : a, 0);
        if (lmax > max) {
          max = lmax;
        }
      }
      document.getElementById('max').textContent = f(Math.ceil(max)) + 'ms';
      const barLength = 1000;
      const barWidth = 20;
      let nb_entries = 0;
      for (const key in urls) {
        const beacon = urls[key];
        let pretty = key;
        const section = htmlElement("section", {id:`entry${nb_entries++}`, style: 'width:100%'}, htmlElement("h2", pretty));
        for (const rt of beacon) {
          if (config.debug) console.log(rt);
          const c = (n) => (n/max)*barLength;
          const svg = svgElement("svg", {width: barLength, height: barWidth+6}, svgElement('g'));
          section.appendChild(svg);
          let shape = svg.firstElementChild;
          let className = "duration";
          if (!rt.responseStart) {
            className="unknown";
          }
          shape.appendChild(svgElement("rect", {class: className,
            width: c(rt.duration),
            x: 0,
            height: barWidth+6, y: 0}));
          if (rt.domainLookupStart) {
            shape.appendChild(svgElement("rect", {class: 'domainLookup',
              width: c(rt.domainLookupEnd-rt.domainLookupStart),
              x: c(rt.domainLookupStart-rt.startTime),
              height: barWidth/1.5, y: (barWidth/6)+3}));
          }
          if (rt.connectStart) {
            shape.appendChild(svgElement("rect", {class: 'connect',
              width: c(rt.connectEnd-rt.connectStart),
              x: c(rt.connectStart-rt.startTime),
              height: barWidth/1.5, y: (barWidth/6)+3}));
          }
          if (rt.requestStart) {
            shape.appendChild(svgElement("rect", {class: 'request',
              width: c((rt.responseStart-rt.requestStart)),
              x: c(rt.requestStart-rt.startTime),
              height: barWidth, y: 3}));
          }
          if (rt.responseStart) {
            shape.appendChild(svgElement("rect", {class: 'response',
              width: c(rt.duration-(rt.responseStart-rt.startTime)),
              x: c(rt.responseStart-rt.startTime),
              height: barWidth/1.5, y: (barWidth/6)+3}));
          }
          if (rt.serverTiming && rt.serverTiming.length > 0) {
            const sts = {};
            for (const st of rt.serverTiming) {
              sts[st.name] = st.duration;
            }
            const resDur = rt.responseStart - rt.requestStart;
            if (sts.monitor > resDur) {
              console.log(`check ${key} ${sts.monitor} < ${resDur}`);
            }
            shape.appendChild(svgElement("rect", {class: 'monitor',
              width: c(sts.monitor),
              x: c(((resDur-sts.monitor)/2)+rt.requestStart-rt.startTime),
              height: barWidth/2, y: barWidth/4 + 3}));
            shape.appendChild(svgElement("rect", {class: 'github',
              width: c(sts.github),
              x: c(((resDur-sts.github)/2)+rt.requestStart-rt.startTime),
              height: barWidth/2, y: barWidth/4 + 3}));
          }
        }
        chart.appendChild(section);
      }
    }

    stats().catch(console.error);
    beacons().catch(console.error);
  </script>
</body>
</html>